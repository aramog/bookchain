// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

import "https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/src/v0.6/ChainlinkClient.sol";
import "./Rental.sol";

// contains all the data for a signle entry (book) in the library
struct Book {
    bytes32 uid;
    bool rented; // true iff the book is currently checked out
    address currentHolder; // if rented, address of the current renter. if not, address of the scanner
    address payable contributor; // original account that added book to collection
    address[] holderHistory; // ordered list of addresses that previously rented the book
    Rental rentalContract; // the rental contract associated with the latest rental. Only valid when rented true.
    uint256 feesCollected; // total revenue generated by this book
    string title; // title of the book
}

contract Library is ChainlinkClient {
    // this variables fully contain the state of the library at any time
    mapping(bytes32 => Book) public bookCollection;
    bytes32[] public allBooks; // list of all the uids that are known to the collection
    uint256 public numBooks; // length of allBooks
    
    // vars for coordinating callback function:
    enum CALLBACK_FLAG { CHECKOUT, CHECKIN, CONTRIBUTE, NONE }
    CALLBACK_FLAG private callbackFlag;
    address payable private lastCaller; // so we can store who the original caller is
    string private lastTitle; // for contributions

    // chainlink vars for communicating with the RFID external adapter
    address private oracle;
    bytes32 private jobId;
    uint256 private fee;

    // default params for rentals
    uint256 private DEFAULT_RENTAL_PERIOD = 14; 
    uint256 private DEFAULT_LATE_FEE = 1;
    
    /**
     * CUSTOM RFID EXTERNAL ADAPTER PARAMS:
     * Network: Kovan
     * Oracle: Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
     * Job ID: Chainlink - 21c2cd07f6e643bab6ab679855ee6643
     * Fee: 0.1 LINK
     */
    constructor() public {
        setPublicChainlinkToken();
        oracle = 0x121927a28b6C5a77064012d8dC0Df3Af81d175de;
        jobId = "21c2cd07f6e643bab6ab679855ee6643";
        fee = 0.1 * 10 ** 18; // 0.1 LINK
        callbackFlag = CALLBACK_FLAG.NONE;
    }
    
    /**
     * Check out book
     */

    function checkOut() public {
        callbackFlag = CALLBACK_FLAG.CHECKOUT;
        lastCaller = msg.sender;
        requestLatestScan();
    }
    
    function checkOutCB(bytes32 _uid) private {
        callbackFlag = CALLBACK_FLAG.NONE;
        // check that uid is in the collection
        assert(inCollection(_uid));
        // check that uid is not currently rented
        assert(!bookCollection[_uid].rented);
        // sets the flags for a checkout
        bookCollection[_uid].rented = true;
        bookCollection[_uid].currentHolder = lastCaller;
        bookCollection[_uid].holderHistory.push(lastCaller);
        // open a Rental contract
        bookCollection[_uid].rentalContract = new Rental(lastCaller, DEFAULT_RENTAL_PERIOD, DEFAULT_LATE_FEE);
        // TODO: make an allowance from the renter to the contract
    }

    /**
     * Check in book
     */
    
    function checkIn() public {
        callbackFlag = CALLBACK_FLAG.CHECKIN;
        lastCaller = msg.sender;
        requestLatestScan();
    }
    
    function checkInCB(bytes32 _uid) private {
        callbackFlag = CALLBACK_FLAG.NONE;
        // check that uid is in the collection
        assert(inCollection(_uid));
        // check that uid is currently rented by lastCaller
        assert(bookCollection[_uid].rented);
        assert(bookCollection[_uid].currentHolder == lastCaller);
        // sets the flags for a checkin
        bookCollection[_uid].rented = false;
        bookCollection[_uid].currentHolder = address(this);
        // logs total fees collected
        bookCollection[_uid].feesCollected += bookCollection[_uid].rentalContract.totalChargedFees();
        // close the Rental contract
        bookCollection[_uid].rentalContract.closeRental(bookCollection[_uid].contributor);
    }

    /**
     * Contribute new book
     */
    
    function contribute(string memory title) public {
        callbackFlag = CALLBACK_FLAG.CONTRIBUTE;
        lastCaller = msg.sender;
        lastTitle = title;
        requestLatestScan();
    }
    
    function contributeCB(bytes32 _uid) private {
        callbackFlag = CALLBACK_FLAG.NONE;
        // makes sure we have a valid uid
        assert(_uid != 0x0);
        // makes sure that book not already in collction
        assert(!inCollection(_uid));
        // adds book to collection
        numBooks += 1;
        allBooks.push(_uid);
        bookCollection[_uid].uid = _uid;
        bookCollection[_uid].contributor = lastCaller;
        bookCollection[_uid].currentHolder = address(this);
        bookCollection[_uid].rented = false;
        bookCollection[_uid].title = lastTitle;
    }
    
    /**
     * Helper function that returns if _uid is contained in allBooks 
     */
    function inCollection(bytes32 _uid) public view returns (bool) {
        for(uint256 i = 0; i< allBooks.length; i++) {
            if (allBooks[i] == _uid) return true;            
        }
        return false;
    }

    /**
     * Function should be called externally every 24hrs, and will update the state of all outstanding rentals.
     */
    function rentalHousekeeping() public {
        for(uint256 i = 0; i< allBooks.length; i++) {
            if (bookCollection[allBooks[i]].rented) {
                // means there's an outstanding rental for book i. so make the dailyCall
                bookCollection[allBooks[i]].rentalContract.dailyCall();
            }
        }
    }
    
    /**
     * Create a Chainlink request to retrieve API response from the RFID reader.
     * _tagUID is the ID of the RFID tag to get the latest scan for
     */
    function requestLatestScan() public returns (bytes32 requestId) {
        // creates the Request
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
        // Sends the request
        return sendChainlinkRequestTo(oracle, req, fee);
    }
    
    /**
     * Receive the response in the form of uint256
     */ 
    function fulfill(bytes32 _requestId, bytes32 uid) public recordChainlinkFulfillment(_requestId) {
        if (callbackFlag == CALLBACK_FLAG.CHECKOUT) {
            checkOutCB(uid);
        } else if (callbackFlag == CALLBACK_FLAG.CHECKIN) {
            checkInCB(uid);
        } else if (callbackFlag == CALLBACK_FLAG.CONTRIBUTE) {
            contributeCB(uid);
        } else {
            // nothing should happen
        }
    }
}
